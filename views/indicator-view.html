<fieldset>
    <legend>Basics</legend>
    <div class="input-group">
        <label for="sli-title-input">
            Title
            <div class="subtle-hint">Make your SLI easier to recognize</div>
        </label>
        <input id="sli-title-input" type="text" v-model="indicator.title" :placeholder="config.title.placeholder">
    </div>

    <div class="input-group">
        <label for="sli-description-input">
            Description
            <div class="subtle-hint">What does this SLI measure in simple words</div>
        </label>
        <textarea
            id="sli-description-input"
            rows="2"
            type="text"
            v-model="indicator.description"
            :placeholder="config.description.placeholder"></textarea>
    </div>
</fieldset>
<fieldset>
    <legend>Budgeting</legend>
    
    <div class="input-group">
        <label>
            Type
            <help-component>
                <p>
                    SLIs can either be either:
                    <ext-link href="https://blog.alexewerlof.com/p/time-based-vs-event-based">
                        event-based or time-based
                    </ext-link>.
                </p>
                <table>
                    <caption>Comparing SLI Types</caption>
                    <thead>
                        <tr>
                            <th></th>
                            <th>Event-Based</th>
                            <th>Time-Based</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Use</td>
                            <td>When consumers perceive reliability by events</td>
                            <td>When consumers perceive reliability by time</td>
                        </tr>
                        <tr>
                            <td>Counts</td>
                            <td>Good events</td>
                            <td>Good timeslices</td>
                        </tr>
                        <tr>
                            <td>Advantage</td>
                            <td>More accurately adjust to the amount of load</td>
                            <td>More forgiving towards the negative impact of failed events</td>
                        </tr>
                        <tr>
                            <td>Formula</td>
                            <td>
                                <math>
                                    <mrow>
                                        <mfrac>
                                            <mrow><mi>Good events</mi></mrow>
                                            <mrow><mi>Valid events</mi></mrow>
                                        </mfrac>
                                        <mrow><mo>×</mo><mn>100</mn></mrow>
                                    </mrow>
                                </math>
                            </td>
                            <td>
                                <math>
                                    <mrow>
                                        <mfrac>
                                            <mrow><mi>Good timeslices</mi></mrow>
                                            <mrow><mi>All timeslices</mi></mrow>
                                        </mfrac>
                                        <mrow><mo>×</mo><mn>100</mn></mrow>
                                    </mrow>
                                </math>
                        </tr>
                    </tbody>

                </table>
            </help-component>
        </label>
        <inline-select-component v-model="indicator.isTimeBased" :options="[
            { title: 'Event-based', value: false },
            { title: 'Time-based', value: true },
        ]"></inline-select-component>
    </div>

    <div v-if="indicator.isTimeBased" class="input-group">
        <!-- SLI timeslice -->
        <label for="sli-event-unit">
            Timeslice: {{ indicator.timeslice }}
            <help-component>
                <p>
                    Time-based SLIs aggregate metric data over a timeslice
                    to mark it as success or failure.
                </p>
                <p>
                    This can also reduce the resolution of the data.
                    For example, probing an endpoint every 60 seconds to see if it is available,
                    assumes that the endpoint is available for the entire 60 seconds.
                </p>
                <p>
                    Another common example is to compare the average of data points with a desired
                    valud. Averages hide the spikes and valleys in the data.
                    It is better to use
                    <ext-link href="https://github.com/alexewerlof/percentile">percentiles</ext-link>
                    instead.
                </p>
                <p>
                    Another example is percentiles. When calculating the 99th percentile of the
                    latency every 5 minutes, the aggregation window is 5 x 60 = 300 seconds.
                </p>
                <table>
                    <caption>Typical timeslice lengths</caption>
                    <thead>
                        <tr>
                            <th>Timeslice</th>
                            <th>Seconds</th>
                            <th aria-label="try button"></th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr v-for="p in config.timeslice.presets">
                            <td>{{ p.title }}</td>
                            <td>{{ p.seconds }}</td>
                            <td><button type="button" @click="indicator.timeslice = p.seconds">Try!</button></td>
                        </tr>
                    </tbody>
                </table>
            </help-component>
        </label>
        <input
            id="sli-event-unit"
            type="range"
            :min="config.timeslice.min"
            :max="config.timeslice.max"
            :step="config.timeslice.step"
            placeholder="60"
            v-model.number="indicator.timeslice">
    </div>
    <div v-if="!indicator.isTimeBased" class="input-group">
        <label for="sli-event-unit">
            Valid events
            <help-component>
                <p>
                    How do consumers perceive reliability of your service?
                    What kind of events are important to the service consumers?
                </p>
                <p>
                    You probably don't want to count all the.
                    This is an opportunity to narrow down the scope of the optimization
                    and what triggers an alert.
                </p>
                <p>
                    For simplicity, sometimes <em>total</em> is used instead of <em>valid</em>.
                    But 
                    <ext-link href="https://blog.alexewerlof.com/p/valid-vs-total">
                        there is a difference
                    </ext-link>.
                </p>
                <p>
                    While
                    <ext-link href="https://blog.alexewerlof.com/p/sli">
                        Service level indicator
                    </ext-link>
                    guides the optimization,
                    the definition of valid scopes that optimization for two reasons:
                    <ul>
                        <li>Focus the optimization effort</li>
                        <li>Clarify responsibility and control</li>
                    </ul>
                </p>
                <p>
                    Note: use a plural form of the event name so that the UI reads more fluently.
                </p>
                <table>
                    <caption>Common events</caption>
                    <thead>
                        <th>Event</th>
                        <th>Use case</th>
                        <th aria-label="try button"></th>
                    </thead>
                    <tbody>
                        <tr v-for="p of config.eventUnit.presets">
                            <td>{{ p.eventUnit }}</td>
                            <td>{{ p.useCase }}</td>
                            <td><button type="button" @click="indicator.eventUnit = p.eventUnit">Try!</button></td>
                        </tr>
                    </tbody>
                </table>
            </help-component>
        </label>

        <input
            id="sli-event-unit"
            type="text"
            v-model="indicator.eventUnit">
    </div>
</fieldset>
<fieldset>
    <legend>Metric</legend>
    <!-- SLI: Good -->
    <div class="input-group">
        <label for="sli-metric-name">
            Name
            <help-component>
                <p>
                    <ext-link href="https://blog.alexewerlof.com/p/sli-good">
                        What are good {{ indicator.eventUnitNorm }}
                    </ext-link>
                    from consumer's perspective?
                    How do good {{ indicator.eventUnitNorm }} look like?
                </p>
                <p>
                    What is the metric that you can measure to identify the
                    good {{ indicator.eventUnitNorm }} from all the valid {{ indicator.eventUnitNorm }}?
                </p>
            </help-component>
        </label>
        <input
            id="sli-metric-name"
            type="text"
            v-model="indicator.metricName">
    </div>

    <fieldset>
        <legend>Data points</legend>
        <div class="input-group">
            <label for="sli-metric-unit">
                Unit
                <help-component>
                    <p>
                        This is the unit of the metric (
                        <label for="sli-metric-name">
                            <code>{{ indicator.metricName }}</code>
                        </label>) not to be confused
                        with the unit of the events (
                        <label for="sli-event-unit">
                            <code>{{ indicator.eventUnitNorm }}</code>
                        </label>).
                    </p>
                </help-component>
                <div class="subtle-hint">For each data point in {{ indicator.metricName }}</div>
            </label>
            <input
                id="sli-metric-unit"
                type="text"
                v-model="indicator.metricUnit"
                :placeholder="config.metricUnit.placeholder">
        </div>
        <div class="input-group">
            <label for="lower-bound-type">
                Lower Bound
                <help-component>
                    <p>
                        <ext-link href="https://blog.alexewerlof.com/p/sli-good">
                            Good
                        </ext-link>
                        values can be bound.
                    </p>
                    <p>
                        The actual
                        <label for="lower-threshold-input">Lower Threshold (<code>$LT</code>)</label>
                        is part of the SLO definition.
                    </p>
                    <p>
                        Using a parameterized SLI allows
                        <ext-link href="https://blog.alexewerlof.com/p/multi-tiered-slos">
                            Multi-Tierd SLOs
                        </ext-link>
                        where different expectations have different commitments.
                    </p>
                </help-component>
                <div class="subtle-hint">
                    Minimum {{ indicator.metricName }} for good {{ indicator.eventUnitNorm }}
                </div>
            </label>
            <div class="warning block" v-if="indicator.lowerBound && hasComparators(indicator.metricName)">
                <p>
                    There seems to be a comparator in the definition of metric already:
                    <label for="sli-metric-name">
                        <code>{{ indicator.metricName }}</code>
                    </label>.
                </p>
                <p>
                    Having another bound makes the formula harder to read.
                    Please use only one way to set the boundaries.
                </p>
            </div>
            <select
                id="lower-bound-type"
                v-model="indicator.lowerBound">
                <option v-for="v of config.lowerBound.possibleValues"
                    :value="v">
                    {{ boundCaption(indicator.metricName, v, '$LT') }}
                </option>
            </select>
        </div>
        <div class="input-group">
            <label for="upper-bound-type">
                Upper Bound
                <help-component>
                    <p>
                        <ext-link href="https://blog.alexewerlof.com/p/sli-good">
                            Good
                        </ext-link>
                        values can be bound.
                    </p>
                    <p>
                        The actual
                        <label for="upper-threshold-input">Upper Threshold (<code>$UT</code>)</label>
                        is part of the SLO definition.
                    </p>
                    <p>
                        Using a parameterized SLI allows
                        <ext-link href="https://blog.alexewerlof.com/p/multi-tiered-slos">
                            Multi-Tierd SLOs
                        </ext-link>
                        where different expectations have different commitments.
                    </p>
                </help-component>
                <div class="subtle-hint">
                    Maximum {{ indicator.metricName }} for good {{ indicator.eventUnitNorm }}
                </div>
            </label>
            <div class="warning block" v-if="indicator.upperBound && hasComparators(indicator.metricName)">
                <p>
                    There seems to be a comparator in the definition of metric already:
                    <label for="sli-metric-name">
                        <code>{{ indicator.metricName }}</code>
                    </label>.
                </p>
                <p>
                    Having another bound makes the formula harder to read.
                    Please use only one way to set the boundaries.
                </p>
            </div>
            <select
                id="upper-bound-type"
                v-model="indicator.upperBound">
                <option v-for="v of config.upperBound.possibleValues"
                    :value="v">
                    {{ boundCaption(indicator.metricName, v, '$UT') }}
                </option>
            </select>
        </div>
    </fieldset>
</fieldset>
<!-- Service Level Formula -->
<h4>
    Service Level Formula
    <help-component>
        <p>
            The formula for calculating SLI for the given SLO window is
            the percentage of good per valid.
        </p>
        <p>
            Depending on whether the SLI is
            <ext-link href="https://blog.alexewerlof.com/p/time-based-vs-event-based">time-based or event-based</ext-link>,
            the formula calculates the percentage of bad time or bad events.
        </p>
        <math>
            <mrow>
                <mi>SLI</mi>
                <mo>=</mo>
                <mfrac>
                    <mrow>
                        <mi>Good {{ indicator.eventUnitNorm }}</mi>
                    </mrow>
                    <mrow>
                        <mi>Valid {{ indicator.eventUnitNorm }}</mi>
                    </mrow>
                </mfrac>
                <mrow>
                    <mo>&times;</mo>
                    <mn>100</mn>
                </mrow>
            </mrow>
        </math>
    </help-component>
</h4>
<div class="code block">
    <div id="sli-formula-code">
        <s-l-fraction-component
            :indicator="indicator"
            time-period="SLO Window"
            time-label-id="slo-window-unit-multiplier"></s-l-fraction-component>
    </div>
    <button @click="copy('sli-formula-code', 'sli-formula')" type="button" title="Copy to clipboard">⎘</button>
</div>

<div class="code block">
    <pre><code>{{JSON.stringify(indicator.toJSON(), null, 2)}}</code></pre>
</div>